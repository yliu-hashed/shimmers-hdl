# ``Shimmers/TopLevel(name:isSequential:)``

## Overview

This macro marks a function as top-level, allowing it to be directly generated by ``SynthDriver``.
Then, you can refer to it by using the ``topLevel(name:of:)`` macro.

This macro can only be attached to a function inside a ``HardwareWire(flatten:)`` data type, or a ``HardwareFunction()`` function. 

Furthermore, this macro does nothing during runtime simulation.

### Creating Top-Level Modules

Shimmers accepts five different types of module constructions:

| |Decorated Function|Module Type|
|--:|:-:|:-:|
|1|Global Function|Combinational|
|2|Static Function|Combinational|
|3|Non-mutating Method|Combinational|
|4|Mutating Method|Combinational|
|5|Mutating Method|Sequential|

#### Global and Static Functions

When you attach it to a global method or static functions, the generated circuit is going to be a fully combinational.
The function arguments are the inputs, and the returned values are the outputs.

```swift
@HardwareWire
struct Instruction {
    @TopLevel
    static func decode(raw: UInt32, stalled: inout Bool) -> Instruction { ... }
    ...
}
```

![A black box built by a global or static function. The inputs are the plain arguments and the in-out arguments. The outputs are the in-out arguments and the return value.](global-static-func)

#### Non-Mutating Methods

Alternatively, you can attach it to a non-mutating method of a struct or enum.
The resulting module is going to be a combinational function where `self` is treated as an additional input. 

```swift
@HardwareWire
struct Instruction {
    @TopLevel
    static func isValid() -> Bool { ... }
    ...
}
```

![A black box built by plain methods. The inputs are the self-value, the plain arguments, and the in-out arguments. The outputs are the in-out arguments and the return value.](plain-method)

#### Mutating Methods

Furthermore, you can attach it to a mutating method of a struct or enum.
This, by default, gives a combinational module where `self` is treated as both an input and an output.

```swift
@HardwareWire
struct Instruction {
    @TopLevel
    mutating func turnIntoNop() -> Bool { ... }
    ...
}
```

![A black box built by a mutating method. The inputs are the self-value, the plain arguments, and the in-out arguments. The outputs are the self value, in-out arguments, and the return value.](mutating-method-comb)

When attached to a mutating method, you can explicitly make it sequential.
This gives a sequential circuit where `self` is the sequential state.
At each clock cycle, the circuit behaves like it executed the attached function once.
The input and output of this circuit are represented by its argument and return values.

```swift
@HardwareWire
struct Counter {
    var value: UInt8 = 0
    @TopLevel(name: "counter", isSequential: true)
    mutating func increment() -> UInt8 {
        value &+= 1
        return value
    }
}
```

![A black box built by a mutating method. The inputs are the self-value, the plain arguments, and the in-out arguments. The outputs are the self-value, in-out arguments, and the return value. The output self-value is connected to a bank of DFFs that wire back into the input self-value. A clock signal controls the DFFs.](mutating-method-seq)

### Generated Port

The port generation follows specific predefined rules:

* The `self` argument changes based on function type.
* The plain arguments are always input ports.
* The `inout` arguments are always input and output ports.
* The Return type is always output ports.

The naming of the port also follows specific redefined rules.
The names are simplified when no `inout` arguments are involved.

|port type|name prefix (w `inout`)|name prefix (w/ `inout`)|
|--:|:-:|:-:|
regular arguments|`i_args_`|`i_`|
return values|`o_rets_`|`o_`|
inout argument input|`i_args_`|n/a|
inout argument output|`o_args_`|n/a|

The `self` value is represented as additional arguments.
Its name has the prefix `i_args_self_` and `o_args_self_`.

