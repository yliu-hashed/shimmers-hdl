# ``Shimmers/Detached()``

## Overview

The detached macro allows the function the be synthesized out-of-line from the caller.

Synthesis of a detached function begins when a piece of code attempts to call this function.
Instead of synthesizing the internal of this function, the caller simply inserts a module instantiation and moves on.
A new synthesis job will be started that produces the module representing this detached function.

> Note:
Unlike the modules generated by the ``TopLevel(name:isSequential:)`` macro, the module generated by ``Detached()`` is not meant to be used directly.

This macro can only be attached to a function inside a ``HardwareWire(flatten:)`` data type, or a ``HardwareFunction()`` function. 

Furthermore, this macro does nothing during runtime simulation.

### Avoid Duplicated Synthesis

Suppose that you have a very `divide(a:b:)` function that's slow to synthesize and slow to prove.
The use of the ``Detached()`` macro allows Shimmers to only synthesize it once.

```swift
@HardwareFunction @Detached
func divide(a: Int, b: Int) -> Int {
    ... // very long
}
```

Without this macro, every time synthesis encounters this function, it will generate a divider.

### Influence on Formal

Since a detached function is synthesized into a separate module, it is isolated from the rest of the synthesis.
The immediate effect is, but not limited to:

* A detached function can be called with arguments that fail the function's assertions.
* The callee will assume the arguments to be free variables.
* The caller will assume the returned values to be free variables.

For example, the following code represents a tightly formally verified design.
In this code, `foo(_:)` calls `bar(_:)`.
The callee `bar(_:)` expects all caller to honor `x<3`,
and the caller `foo(_:)` expects the `bar(_:)` to return a value `v<6`.

```swift
@HardwareFunction
func foo(_ x: UInt8) -> UInt8 {
    let v = bar(x % 3)
    #assert(v < 6) // expectation on return value
    return v
}

@HardwareFunction @Detached
func bar(_ x: UInt8) -> UInt8 {
    #assert(x < 3) // expectation on argument
    return x + 3
}
```

Without the `@Detached` marker on `bar(_:)`, this code will pass synthesis.
However, with the `@Detached` marker, both assertions will fail.
The synthesis of `bar(_:)` is unaware of anything in its caller `foo(_:)`.
The synthesis of `foo(_:)` is also unaware of the return value of the callee `bar(_:)`.

To achieve the same level of guarantee about correctness, the following needs to be done:

* Move assertions about arguments into the caller.
* Add assumptions about arguments into the detached callee.
* Move assertions about return values into the detached callee.
* Add assumptions about return values into the caller.

Writing a wrapper function is highly recommended when numerous formal verifications are placed on arguments and return values.
For example, the previous example can be converted to this:

```swift
@HardwareFunction
func foo(_ x: UInt8) -> UInt8 {
    let v = bar(x % 3)
    return v
}

// wrapper
@HardwareFunction
func bar(_ x: UInt8) -> UInt8 {
    #assert(x < 3) // expectation on argument
    let v = bar_body(x) // call into body (detached)
    #assume(x < 6) // expectation on return value
    return v
}

@HardwareFunction @Detached
func bar_body(_ x: UInt8) -> UInt8 {
    #assume(x < 3) // expectation on argument
    let v = x + 3
    #assert(x < 6) // expectation on return value
    return v
}
```
