//
//  Shimmers/Graph/Print Verilog.swift
//  shimmers-hdl
//
// This Source Code Form is subject to the terms of the Mozilla Public License 2.0.
// SPDX-License-Identifier: MPL-2.0
//

import Foundation

extension GraphBuilder {

    private func dumpWires<List: Collection<UInt32>>(in list: List, into str: inout String) {
        var line = ""
        for num in list {
            let wn = "w\(num)"
            if line.isEmpty {
                line = "wire \(wn)"
                continue
            }
            if line.count + wn.count + 4 > 60 {
                str += "  \(line);\n"
                line = "wire \(wn)"
            } else {
                line += ",\(wn)"
            }
        }
        if !line.isEmpty { str += "  \(line);\n"}
    }

    func buildVerilog(namePrefix: consuming String, name: String, printIncludes: Bool) -> String {
        simplify()

        let guardName = buildFileName(for: name).uppercased()

        var str = ""
        str += "// Generated by Shimmers on \(Date())\n"
        str += "// This is an auto generated file, DO NOT MODIFY!\n"
        str += "`ifndef __\(guardName)\n"
        str += "`define __\(guardName)\n"
        str += "`default_nettype none\n"

        if printIncludes {
            for submodule in modules {
                let fileName: String = buildFileName(for: submodule.name) + ".v"
                str += "`include \"\(fileName)\"\n"
            }
        }

        func wireName(seq: UInt32) -> String {
            return "w\(seq)"
        }
        func wireName(_ wire: _WireID) -> String {
            let id = wire.id
            if id == 0 { return "1'b0" }
            if id == 1 { return "1'b1" }

            if id & 1 == 1 {
                return "!w\(id >> 1)"
            } else {
                return "w\(id >> 1)"
            }
        }
        func bitExpression(width: Int) -> String {
            if width == 1 {
                return String(repeating: " ", count: 9)
            } else {
                let raw = "\(width-1):0"
                let padded = String(repeating: " ", count: 7 - raw.count) + raw
                return "[\(padded)]"
            }
        }
        // print module ports
        str += "module \\\(verilogMangle(name: name)) (\n"
        str += "  input CLK"
        for port in inputs {
            let bits = bitExpression(width: port.width)
            str += ",\n  input  \(bits) \(port.name)";
        }
        for port in outputs {
            let bits = bitExpression(width: port.width)
            str += ",\n  output \(bits) \(port.name)";
        }
        str += "\n  );\n"

        str += "  // INPUT PORTS -----------------------\n"
        for port in inputs {
            dumpWires(in: port.minSeq...port.maxSeq, into: &str)
            str += "  assign {\((port.minSeq...port.maxSeq).reversed().map(wireName(seq:)).joined(separator: ","))} = \(port.name);\n"
        }

        if !modules.isEmpty {
            str += "  // SUBMODULES ------------------------\n"
            for (index, module) in modules.enumerated() {
                let wiresSeqs = module.outputs.lazy.flatMap(\.wires).map({ $0.id >> 1 })
                dumpWires(in: wiresSeqs, into: &str)

                str += "  \\\(verilogMangle(name: module.name)) \\\(verilogMangle(name: module.name))_\(index) (\n"
                str += "    .CLK(CLK)"
                for port in module.inputs {
                    str += ",\n    .\(port.name)({\(port.wires.reversed().map(wireName(_:)).joined(separator: ","))})"
                }
                for port in module.outputs {
                    str += ",\n    .\(port.name)({\(port.wires.reversed().map(wireName(_:)).joined(separator: ","))})"
                }
                str += ",\n  );\n"
            }
        }

        if !gates.isEmpty {
            str += "  // GATES -----------------------------\n"
            for (gate, seq) in gates {
                switch gate {
                case .and(a: let a, b: let b):
                    str += "  wire \(wireName(seq: seq)) = \(wireName(a)) && \(wireName(b));\n"
                case .xor(a: let a, b: let b):
                    str += "  wire \(wireName(seq: seq)) = \(wireName(a)) != \(wireName(b));\n"
                case .mux(s: let s, t: let t, f: let f):
                    str += "  wire \(wireName(seq: seq)) = \(wireName(s)) ? \(wireName(t)) : \(wireName(f));\n"
                case .dff(d: let d):
                    str += "  reg \(wireName(seq: seq)) = 0;\n"
                    str += "  always @(posedge CLK) \(wireName(seq: seq)) <= \(wireName(d));\n"
                }
            }
        }

        str += "  // OUTPUT PORTS ----------------------\n"
        for port in outputs {
            str += "  assign \(port.name) = {\(port.bits.reversed().map(wireName(_:)).joined(separator: ","))};\n"
        }

        str += "endmodule\n"
        str += "`endif // __\(guardName)\n"
        return str
    }
}
